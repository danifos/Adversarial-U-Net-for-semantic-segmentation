/**
 * Script to calculate the segmentation error between some 2D 
 * original (binary) labels and their corresponding proposed labels (binary or
 * probability -0-1- values).
 * 
 * The evaluation metrics are:
 *  - Maximal foreground-restricted Rand score after thinning
 *  - Maximal foreground-restricted information theoretic score after thinning
 * 
 * These are the final official metrics for the ISBI-2012 challenge
 * on segmentation of neuronal structures in EM stacks (http://brainiac2.mit.edu/isbi_challenge/).
  * 
 * @author Ignacio Arganda-Carreras (ignacio.arganda@ehu.eus)
 * @version January 12, 2016
 */
  
import trainableSegmentation.metrics.*;
import ij.WindowManager;
import ij.gui.GenericDialog;
import ij.IJ;
  
// Get the list of images that are open
ids = WindowManager.getIDList();
  
if ( ids == null || ids.length < 2 )
{
    IJ.showMessage( "You should have at least two images open." );
    return;
}
  
// Get all the titles of the open images        
titles = new String[ ids.length ];
for ( int i = 0; i < ids.length; ++i )
{
    titles[ i ] = ( WindowManager.getImage( ids[ i ] ) ).getTitle();
}
  
// Create dialog        
gd = new GenericDialog( "Evaluate segmentation results" );
          
gd.addMessage( "Image Selection:" );
current = WindowManager.getCurrentImage().getTitle();
gd.addChoice( "Original_labels", titles, current );
gd.addChoice( "Proposal", titles, current.equals( titles[ 0 ] ) ? titles[ 1 ] : titles[ 0 ] );
          
gd.addMessage( "Segmentation error metrics:" );
gd.addCheckbox( "Maximal foreground-restricted Rand score after thinning", true );
gd.addCheckbox( "Maximal foreground-restricted information theoretic score after thinning", true );

gd.addMessage( "Data selection:" );
gd.addCheckbox( "Binary proposal", false );
 
gd.showDialog();
          
if (gd.wasCanceled()) 
    return;
          
originalLabels = WindowManager.getImage( ids[ gd.getNextChoiceIndex() ] );
proposedLabels = WindowManager.getImage( ids[ gd.getNextChoiceIndex() ] );
  
calculateVRandAfterThinning = gd.getNextBoolean();
calculateVInfoAfterThinning = gd.getNextBoolean();

binaryProposal = gd.getNextBoolean();
  
IJ.log("---");
IJ.log("Evaluating segmentation...");
IJ.log("  Original labels: " + originalLabels.getTitle());
IJ.log("  Proposed labels: " + proposedLabels.getTitle() + "\n");

// Calculate segmentation error with the selected metrics
  
if( calculateVRandAfterThinning )
{   
    IJ.log("\nCalculating maximal foreground-restricted Rand score after thinning...");
    metric = new RandError( originalLabels, proposedLabels );
    maxThres = binaryProposal ? 0.0 : 1.0;
    maxScore = metric.getMaximalVRandAfterThinning( 0.0, maxThres, 0.1, true );  
    IJ.log("  Maximum foreground-restricted Rand score after thinning: " + maxScore );     
}

if( calculateVInfoAfterThinning )
{   
    IJ.log("\nCalculating maximal foreground-restricted information theoretic score after thinning...");
    metric = new VariationOfInformation( originalLabels, proposedLabels );
    maxThres = binaryProposal ? 0.0 : 1.0;
    maxScore = metric.getMaximalVInfoAfterThinning( 0.0, maxThres, 0.1 );  
    IJ.log("  Maximum foreground-restricted information theoretic score after thinning: " + maxScore );     
}